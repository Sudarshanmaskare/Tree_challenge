/////Type = Offline query

struct Trie{
  Trie* bit[2];
  Trie(){
      bit[0]=bit[1]=NULL;
  }
};
class Solution {
    Trie *root;
public:
    Solution(){
        root=new Trie();
    }
    
    void insert(int num){
        Trie* cur=root;
        for(int i=31;i>=0;i--){
            int ind=(num>>i)&1;
            if(!cur->bit[ind]){
                cur->bit[ind]=new Trie();
            }
            cur=cur->bit[ind];
        }
    }
    
    int cal_max(int num){
        Trie* cur=root;
        int ans=0;
        for(int i=31;i>=0;i--){
            int ind=(num>>i)&1;
            if(cur->bit[!ind]){
                ans|=(1<<i);
                cur=cur->bit[!ind];
            }
            else{
                cur=cur->bit[ind];
            }
        }
        return ans;
    }
    static bool compare(vector<int> &a,vector<int> &b){
        return a[1]<b[1];
    }
    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {
        int n=nums.size();
        int q=queries.size();
        
        sort(nums.begin(),nums.end());
        vector<vector<int>> temp;
        for(int i=0;i<q;i++){
            vector<int> cal;
            cal.push_back(queries[i][0]);
            cal.push_back(queries[i][1]);
            cal.push_back(i);
            temp.push_back(cal);
        }
        sort(temp.begin(),temp.end(),compare);
        
        vector<int> ans(q,0);
        int ind=0;
        for(int i=0;i<q;i++){
            int var=temp[i][0],less=temp[i][1],qind=temp[i][2];
            while(ind<n && nums[ind]<=less){
                insert(nums[ind]);
                ind++;
            }
            if(ind==0) ans[qind]=-1;
            else{
                ans[qind]=cal_max(var);
            }
        }
       
        return ans;
    }
};
